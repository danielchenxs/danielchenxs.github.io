---

layout:     post
title:      "Mysql锁"
subtitle:   ""
date:       2019-07-21
author:     "Chenxs"
header-img: "img/post-bg-js-version.jpg"
tags:
    - Mysql
    - 锁
---

## Mysql锁

#### MySQL有三种锁的级别：页级、表级、行级。

`表级锁`：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。

`行级锁`：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。

`页面锁`：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

算法：

`next KeyLocks锁`，Record Lock+Gap Lock，锁定一个范围，并且锁定记录本身

`Gap锁`：间隙锁，锁定一个范围，但不包含记录本身；

`Recordlock锁`：单个行记录上的锁，我们通常讲的行锁，它的实质是通过对索引的加锁实现；只有通过索引条件检索数据，InnoDB才使用行级锁

> 所以其实 Next-KeyLocks=Gap锁+ Recordlock锁



### 读锁与写锁

- 读锁：共享锁、Shared Locks 、S锁
- 写锁：排他锁、Exclusive Locks、 X锁
- select: 不加锁

|      | X    | S      |
| ---- | ---- | ------ |
| X    | 冲突 | 冲突   |
| S    | 冲突 | 不冲突 |

  

#### 读操作

普通select

#### 加读锁

```sql
select...lock in share mode
```

#### 加写锁

```sql
select ... for update
```



####  写操作



- DELETE：删除一条数据时，先对记录加X锁，再执行删除操作。

- INSERT：插入一条记录时，会先加`隐式锁`来保护这条新插入的记录在本事务提交前不被别的事务访问到。

- UPDATE

  - 如果被更新的列，修改前后没有导致储存空间变化，那么会先给记录加X锁，再直接对记录进行修改。
  - 如果被更新的列，修改前后导致存储空间发生了变化，那么会先加X锁，然后将记录删掉，在Insert一条新的记录。

  > 隐式锁：一个事务插入一条记录后，还未提交，这条记录会保存本次事务id，而其他事务想来对这个记录加锁时，会发现事务id不对应，这时会产生X锁，所以相当于在插入一条记录时，隐式的给这条记录加了一把隐式X锁。



#### 行锁

- LOCK_REC_NOT_GAP：单个行记录上的锁
- LOCK_GAP：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况
- LOCK_ORDINARY (next-key lock)：RR级别，锁住记录本身和记录之前的 gap，对于行的查询，都是采用该方法，主要目的是解决幻读的问题。

### 表锁

#### 表级别的S锁，X锁



对表进行DDL语句时，其他事务对这个表进行select、insert、delete、update会发生阻塞。反过来执行以上操作时，DDL也会被阻塞。这个过程是通过使用元数据锁来实现的。

- LOCK TABLES t1 READ : t1 加表级别S锁
- LOCK TABLES t1 WRITE : t1 加表级别X锁

> 尽量不要用这两种方式去加锁，InnoDB有优点是行锁，所以尽量用行锁，性能更高。

#### IS锁，IX锁（表锁）

意向锁是InnoDB自动加的，不需要用户干预。

> 仅仅是为了在之后加表级别锁的S锁和X锁时能快速判断表中的记录是否被上锁。

- IS锁：意向共享锁、Intention Shared Lock。当事务准备在某条记录上加S锁时，需要在表级别加一个IS锁。
- IX锁：意向排他锁、Intention Shared Lock。当事务在某条记录上加X锁时，需要再表级别加一个IX锁。

`结论`
作用：意向锁提高了锁定父节点时的效率（相当于一个全局标记位）
原理：可以直接通过目标节点的意向锁便得知是否可以对目标表进行加锁，而不需要遍历该节点的所有子节点。
场景：在支持多粒度的层级结构锁定的数据库中，锁定父节点时有效

#### 什么情况下会造成死锁



> 所谓死锁<DeadLock>: 是指两个或两个以上的进程在执行过程中,
> 因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.
> 此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等待的进程称为死锁进程.
> 表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.

死锁的关键在于：**`两个(或以上)的Session加锁的顺序不一致。`**

那么对应的解决死锁问题的关键就是：**`让不同的session加锁有次序`**

默认情况下，InnoDB工作在可重复读隔离级别下，并且会以Next-Key Lock的方式对数据行进行加锁，这样可以有效防止幻读的发生。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。

> `结论`
> 作用：意向锁提高了锁定父节点时的效率（相当于一个全局标记位）
> 原理：可以直接通过目标节点的意向锁便得知是否可以对目标表进行加锁，而不需要遍历该节点的所有子节点。
> 场景：在支持多粒度的层级结构锁定的数据库中，锁定父节点时有效

> 《数据库系统实现》7.6.2节有说明。 对表级别的IX、IS 只和对表级别的 X 、S 有关系。即表级别的IX与表级别的 X、S均不相容，表级别的IS只于表级别的S相容。 而表级别的IX、IS是相互相容的，而IX、IS只是表明申请更低层次级别元素（比如 page、记录）的X、S操作。



参考原文： [<u>MySQL 加锁处理分析</u>](http://hedengcheng.com/?p=771)



