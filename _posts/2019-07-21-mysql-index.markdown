---

layout:     post
title:      "Mysql索引相关"
subtitle:   ""
date:       2019-07-21
author:     "Chenxs"
header-img: "img/post-bg-js-version.jpg"
tags:
    - Mysql
    - 索引
---

# Mysql索引相关

#### 索引是什么？

  索引（Index）是帮助Mysql高效获取数据的数据结构。可以得到索引的本质：索引是数据结构。



#### 局部性原理

> 当一个数据被用到时，其附近的数据也通常会马上被使用。
>
> 程序运行期间所需要的数据通常比较集中

#### 磁盘预读

为了减少磁盘IO，通常不是按需读取，预读的长度一般为页（page）的整倍数。Innodb默认16kb一页

```sql
show global status like 'Innodb_page_size';
```



#### 储存引擎

1. `Innodb` mysql默认，支持事务，行锁等，保证了数据完整性，并发性。 数据和索引在一个文件中。
2. `Myisam` 插入数据快，空间和内存使用比较低。不支持事务，行锁。数据和索引是分开的。
3. `Memory`  所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。





#### 优势

- 类似建书目索引，提高数据检索的效率，降低数据库的IO成本
- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗

#### 劣势：

- 虽然提高查询速度，但同时会降低更新表的速度，如对表进行INSERT, UPDATE 和 DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。
- 实际上索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以索引列也是要`占用空间`的。



#### 哪些情况需要创建索引：

1. 主键自动建立唯一索引

2. 频繁作为查询条件的字段应该创建索引

3. 查询中与其他表关联的字段，外键关系建立索引

4. 单键/组合索引的选择问题，组合索引性价比更高

5. 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度

6. 查询中统计或者分组字段

   <!--分组包含排序：先排序后分组-->

#### 哪些情况不要建索引：

1. 表记录太少
2. 经常增删改的表或者字段
3. where 条件里用不到的字段不创建索引
4. 过滤性不好的不适合建索引 



### 索引存储类型

Mysql索引主要有两种结构：`B+Tree索引`和`Hash索引`.



### B-Tree索引

InnoDB使用的是B+Tree。
B+Tree：每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。

B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，很适合查找范围数据。

B-Tree可以对<，<=，=，>，>=，BETWEEN，IN，以及不以通配符开始的LIKE使用索引。



按索引的`最左边前缀`(leftmost prefix of the index)来进行查询：

> 1. 查询必须从索引的最左边的列开始，否则无法使用索引
> 2. 不能跳过某一索引列
> 3. 存储引擎不能使用索引中范围条件右边的列。如`like A%`



## 聚簇索引（**cluster index**）

[原文地址](https://www.linuxidc.com/Linux/2018-02/150809.htm)

目前，只有solidDB和InnoDB支持聚簇索引，MyISAM不支持聚簇索引。一些DBMS允许用户指定聚簇索引，但是MySQL的存储引擎到目前为止都不支持。

### **InnoDB的聚簇索引：**

> 1. InnoDB对主键建立聚簇索引。
> 2. 如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。
> 3. 如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。
> 4. 一个表中只能有一个聚簇索引（因为无法同时把数据行存放在两个不同的地方）



### **聚簇索引结构：**

聚簇索引的结构大致如下：

- **聚簇索引（主键索引）：**节点页只包含了索引列，叶子页包含了行的全部数据。聚簇索引“就是表”，因此可以不需要独立的行存储。
- **二级索引（二级索引）：**叶子节点保存的不是指行的物理位置的指针，而是行的主键值。



![img](https://www.linuxidc.com/upload/2018_02/180207192985425.png)





1. 二次索引的叶子节点找到主键值 
2. 通过主键值去局促索引找到对应的行(回表)。 

```
优点：相关数据保存在一起，磁盘读取少数的数据页就可以获得结果，减少磁盘IO
缺点：插入速度严重依赖插入顺序。
```

需要二次索引查找（`回表`）。

注意点：向聚簇索引插入无序的索引 

> 1. 写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB 在插入之前不得不先找到并从磁盘读取目标页到内存中。这将导致大量的随机 I/O。 

> 2. 因为写入是乱序的，InnoDB不得不频繁的做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。 

> 3. 由于频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片。 

**聚簇索引优点：**

1. 可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。
2. 数据访问更快。聚簇索引将索引和数据保存在同一个 B-Tree 中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。
3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

**聚簇索引缺点：**

1. 聚簇数据最大限度地提高了 I/O 密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了。聚簇索引也就没扫描优势了。
2. **插入速度严重依赖于插入顺序**。按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式。但如果不是按照主键顺序加载数据，那么加载完成后最好使用 OPTIMIZE TABLE 命令重新组织一下表。
3. 更新聚簇索引列的代价很高，因为会强制 InnoDB 将每个被更新的行移动到新的位置。
4. 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂（page split）”的问题。当行的主键值要求必须将这一行插入到某个已满的页时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂的操作。页分裂会导致表占用更多的磁盘空间。
5. 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。
6. 二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。
7. 二级索引访问需要两次索引查找，而不是一次。

> 为什么二级索引需要两次索引查找？因为二级索引的叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。这就意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。这里做了重复的操作：两次 B-Tree 查找而不是一次。

`查询过程(如果不是覆盖索引需要查询两次B-Tree)`： 

（`覆盖索引`:指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。）：二次索引就能得到查询记录，不需要去查询聚簇索引。 



#### 索引条件下推（ICP：index condition pushdown）：

Explain 中显示 （extra:`Using index condition`）

<!--b是非聚簇索引-->。

```sql
select * from t1 where b=1 and b like '%1';
```

`原理：`获取主键之前，先通过其他的条件进行一波过滤，再回表。

mysql5.7之前的优化：`索引-> 主键->回表->其他条件过滤`

mysql5.7之后的优化：`索引->其他条件过滤->主键->回表`

 

#### Explain:

通过key_len 可以算出大概用了哪些索引（比如一个可为null的int值len=1+4=5）

如果用到聚簇索引，则只显示该索引长度，且key=PRIMARY。


`type`：索引类型

- index: 聚簇索引
- ref:非聚簇索引
- all:全表扫描 


